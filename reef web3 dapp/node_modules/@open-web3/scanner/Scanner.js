"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _apiDerive = require("@polkadot/api-derive");

var _types = require("@polkadot/types");

var _typesKnown = require("@polkadot/types-known");

var _util = require("@polkadot/util");

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _GenericEvent = _interopRequireDefault(require("./GenericEvent"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

class Scanner {
  constructor(options) {
    this.rpcProvider = void 0;
    this.knownTypes = void 0;
    this.metadataRequest = void 0;
    this.wsProvider = void 0;
    this.chainInfo = void 0;
    this.wsProvider = options.wsProvider;
    this.rpcProvider = options.rpcProvider || options.wsProvider;
    this.knownTypes = {
      types: options.types,
      typesAlias: options.typesAlias,
      typesBundle: options.typesBundle,
      typesChain: options.typesChain,
      typesSpec: options.typesSpec
    };
    this.chainInfo = {};
    this.metadataRequest = {};
  }

  createMethodSubscribe(methods, ...params) {
    const [updateType, subMethod, unsubMethod] = methods;
    return new _rxjs.Observable(observer => {
      let subscriptionPromise = Promise.resolve();

      const errorHandler = error => {
        observer.error(error);
      };

      try {
        const update = (error, result) => {
          if (error) {
            // errorHandler(error)
            return;
          }

          observer.next(result);
        };

        subscriptionPromise = this.wsProvider.subscribe(updateType, subMethod, params, update).catch(error => errorHandler(error));
      } catch (error) {
        errorHandler(error);
      }

      return () => {
        subscriptionPromise.then(subscriptionId => (0, _util.isNumber)(subscriptionId) ? this.wsProvider.unsubscribe(updateType, unsubMethod, subscriptionId) : Promise.resolve(false));
      };
    });
  }

  async getBlockDetail(_blockAt) {
    var _extrinsics$, _extrinsics$$args;

    const blockAt = await this.getBlockAt(_blockAt);
    const chainInfo = await this.getChainInfo(blockAt);
    const requestes = [];
    requestes.push(this.getEvents(blockAt, chainInfo).then(eventRecords => eventRecords.map((event, index) => this.getEventData(event, index))));
    const blockRaw = await this.rpcProvider.send('chain_getBlock', [blockAt.blockHash]);
    requestes.push(this.getHeader(blockRaw.block.header, blockAt, chainInfo).then(header => {
      var _header$author;

      return (_header$author = header.author) === null || _header$author === void 0 ? void 0 : _header$author.toString();
    }));
    const [events, author] = await Promise.all(requestes);
    const extrinsics = blockRaw.block.extrinsics.map((extrinsic, index) => {
      const event = [...events].reverse().find(({
        phaseIndex
      }) => phaseIndex === index);
      const result = event && (event.method === 'ExtrinsicFailed' || event.method === 'ExtrinsicSuccess') ? event.method : '';
      return _objectSpread({
        index,
        result
      }, this.decodeTx(extrinsic, blockAt, chainInfo));
    });
    const timestamp = extrinsics === null || extrinsics === void 0 ? void 0 : (_extrinsics$ = extrinsics[0]) === null || _extrinsics$ === void 0 ? void 0 : (_extrinsics$$args = _extrinsics$.args) === null || _extrinsics$$args === void 0 ? void 0 : _extrinsics$$args.now;
    return {
      raw: blockRaw,
      number: Number(blockRaw.block.header.number),
      hash: blockAt.blockHash,
      timestamp,
      author,
      events,
      extrinsics,
      chainInfo
    };
  }

  async getHeader(header, _blockAt, meta) {
    const validators = await this.getSessionValidators(_blockAt);
    return (0, _apiDerive.createHeaderExtended)(meta.registry, meta.registry.createType('Header', header), validators);
  }

  async getRuntimeVersion(blockHash) {
    const [runtimeVesion, chainName] = await Promise.all([this.rpcProvider.send('state_getRuntimeVersion', [blockHash]), this.rpcProvider.send('system_chain', [])]);
    return _objectSpread(_objectSpread({}, runtimeVesion), {}, {
      chainName
    });
  }

  async getBlockHash(at) {
    if (typeof at === 'number' && !isNaN(at) && !(0, _util.isHex)(at)) {
      const blockHash = this.rpcProvider.send('chain_getBlockHash', [at]);
      return blockHash;
    } else {
      return at;
    }
  }

  async getBlockAt(blockAt) {
    if (blockAt !== null && blockAt !== void 0 && blockAt.blockHash && (blockAt === null || blockAt === void 0 ? void 0 : blockAt.blockNumber) !== undefined) {
      return {
        blockHash: blockAt.blockHash,
        blockNumber: blockAt.blockNumber
      };
    }

    if (!blockAt) {
      const header = await this.rpcProvider.send('chain_getHeader', []);
      const blockNumber = Number(header.number);
      const blockHash = await this.rpcProvider.send('chain_getBlockHash', []);
      return {
        blockNumber: blockNumber,
        blockHash: blockHash
      };
    } else if (blockAt.blockNumber !== undefined) {
      const blockHash = await this.rpcProvider.send('chain_getBlockHash', [blockAt.blockNumber]);
      return {
        blockNumber: blockAt.blockNumber,
        blockHash: blockHash
      };
    } else if (blockAt.blockHash) {
      const header = await this.rpcProvider.send('chain_getHeader', [blockAt.blockHash]);
      return {
        blockNumber: Number(header.number),
        blockHash: blockAt.blockHash
      };
    } else {
      throw new Error('expect blockHash or blockNumber');
    }
  }

  async getParentHash(_blockHash) {
    const header = await this.rpcProvider.send('chain_getHeader', _blockHash ? [_blockHash] : []);
    return header.parentHash;
  }

  getSpecTypes(version) {
    const types = (0, _typesKnown.getSpecTypes)({
      knownTypes: this.knownTypes
    }, version.chainName, version.specName, version.specVersion);
    return _objectSpread(_objectSpread({}, types), {}, {
      GenericEvent: _GenericEvent.default
    });
  }

  async getChainInfo(_blockAt) {
    const {
      blockHash,
      blockNumber
    } = await this.getBlockAt(_blockAt);
    let hashForMetadata = await this.getParentHash(blockHash);

    if (blockNumber === 0) {
      hashForMetadata = blockHash;
    }

    const runtimeVersion = await this.getRuntimeVersion(hashForMetadata);
    const cacheKey = `${runtimeVersion.specName}/${runtimeVersion.specVersion}`;

    if (!this.chainInfo[cacheKey]) {
      const registry = new _types.TypeRegistry();
      registry.register(this.getSpecTypes(runtimeVersion));
      const properties = await this.rpcProvider.send('system_properties', []);
      registry.setChainProperties(registry.createType('ChainProperties', properties));
      registry.knownTypes.typesAlias = this.knownTypes.typesAlias; // eslint-disable-next-line

      if (!this.metadataRequest[cacheKey]) {
        this.metadataRequest[cacheKey] = this.rpcProvider.send('state_getMetadata', [hashForMetadata]).then(rpcdata => {
          const metadata = new _types.Metadata(registry, rpcdata);
          registry.setMetadata(metadata);
          return {
            id: cacheKey,
            min: blockNumber,
            max: blockNumber,
            bytes: rpcdata,
            metadata: (0, _types.expandMetadata)(registry, metadata),
            registry: registry,
            runtimeVersion: runtimeVersion
          };
        });
      }

      this.chainInfo[cacheKey] = await this.metadataRequest[cacheKey];
    } else {
      this.chainInfo[cacheKey].min = Math.min(this.chainInfo[cacheKey].min, blockNumber);
      this.chainInfo[cacheKey].max = Math.max(this.chainInfo[cacheKey].max, blockNumber);
    }

    return this.chainInfo[cacheKey];
  }

  async getSessionValidators(_blockAt) {
    const {
      metadata,
      registry
    } = await this.getChainInfo(_blockAt);
    if (!metadata.query.session) return [];
    const storageKey = new _types.StorageKey(registry, metadata.query.session.validators);
    return this.getStorageValue(storageKey, _blockAt);
  }

  async getEvents(_blockAt, meta) {
    const storageKey = new _types.StorageKey(meta.registry, meta.metadata.query.system.events);
    return this.getStorageValue(storageKey, _blockAt);
  }

  getEventData(event, index) {
    var _event$event$meta$toJ, _event$event$meta$toJ2;

    const documentation = (_event$event$meta$toJ = event.event.meta.toJSON()) === null || _event$event$meta$toJ === void 0 ? void 0 : (_event$event$meta$toJ2 = _event$event$meta$toJ.documentation) === null || _event$event$meta$toJ2 === void 0 ? void 0 : _event$event$meta$toJ2.join('\n');
    return {
      index,
      doc: documentation,
      bytes: event.toHex(),
      section: event.event.section,
      method: event.event.method,
      phaseType: event.phase.type,
      phaseIndex: event.phase.isNone ? null : event.phase.value.toNumber(),
      args: event.event.data.toJSON(),
      argsDef: event.event.argsDef
    };
  }

  async getStorageValue(storageKey, _blockAt) {
    const blockAt = await this.getBlockAt(_blockAt);
    const {
      registry
    } = await this.getChainInfo(_blockAt);
    const raw = await this.rpcProvider.send('state_getStorage', [storageKey.toHex(), blockAt.blockHash]); // eslint-disable-next-line

    return registry.createType(storageKey.outputType, raw, true);
  }

  decodeTx(txData, _blockAt, meta) {
    const extrinsic = new _types.GenericExtrinsic(meta.registry, txData);
    const {
      callIndex,
      args
    } = extrinsic.method.toJSON();
    return {
      bytes: txData,
      hash: (0, _util.u8aToHex)(extrinsic.hash),
      tip: extrinsic.tip.toString(),
      nonce: extrinsic.nonce.toNumber(),
      method: extrinsic.method.method,
      section: extrinsic.method.section,
      signer: extrinsic.isSigned ? extrinsic.signer.toString() : null,
      callIndex,
      args
    };
  }

  subscribeNewBlockNumber(confirmation) {
    let newBlockNumber$;

    if (confirmation === 'finalize') {
      newBlockNumber$ = this.createMethodSubscribe(['chain_finalizedHead', 'chain_subscribeFinalizedHeads', 'chain_unsubscribeFinalizedHeads']).pipe((0, _operators.map)(header => Number(header.number)));
    } else if (typeof confirmation === 'number') {
      newBlockNumber$ = this.createMethodSubscribe(['chain_newHead', 'chain_subscribeNewHead', 'chain_unsubscribeNewHead']).pipe((0, _operators.map)(header => Number(header.number) - confirmation >= 0 ? Number(header.number) - confirmation : 0));
    } else {
      newBlockNumber$ = this.createMethodSubscribe(['chain_newHead', 'chain_subscribeNewHead', 'chain_unsubscribeNewHead']).pipe((0, _operators.map)(header => Number(header.number)));
    }

    return newBlockNumber$.pipe((0, _operators.shareReplay)({
      bufferSize: 1,
      refCount: true
    }), (0, _operators.pairwise)(), (0, _operators.mergeMap)(([pre, current]) => {
      if (pre >= current) return (0, _rxjs.of)(current);
      return (0, _rxjs.of)(...[...Array(current - pre).keys()].map(i => i + 1 + pre));
    }));
  }

  subscribe(options = {}) {
    const {
      start,
      end,
      concurrent = 10,
      confirmation
    } = options;
    let blockNumber$;

    if (start !== undefined && end !== undefined) {
      blockNumber$ = (0, _rxjs.range)(start, end - start + 1);
    } else if (start !== undefined && end === undefined) {
      const newBlockNumber$ = this.subscribeNewBlockNumber(confirmation);
      blockNumber$ = (0, _rxjs.from)(newBlockNumber$).pipe((0, _operators.take)(1), (0, _operators.switchMap)(lastestNumber => {
        return (0, _rxjs.concat)((0, _rxjs.range)(start, lastestNumber - start + 1), newBlockNumber$);
      }));
    } else {
      blockNumber$ = this.subscribeNewBlockNumber(confirmation);
    }

    const getBlockDetail = blockNumber => {
      return new _rxjs.Observable(subscriber => {
        this.getBlockDetail({
          blockNumber
        }).then(data => {
          subscriber.next({
            blockNumber,
            result: data,
            error: null
          });
          subscriber.complete();
        }).catch(error => {
          subscriber.error(error);
        });
      }).pipe((0, _operators.timeout)(options.timeout || 60000), (0, _operators.retryWhen)(errors => errors.pipe((0, _operators.mergeMap)(error => {
        if (error.name !== 'TimeoutError') {
          return (0, _rxjs.throwError)(error);
        }

        return (0, _rxjs.timer)(5000);
      }))), (0, _operators.catchError)(err => {
        return (0, _rxjs.of)({
          blockNumber,
          error: err,
          result: null
        });
      }));
    };

    return blockNumber$.pipe((0, _operators.mergeMap)(value => getBlockDetail(value), concurrent));
  }

}

var _default = Scanner;
exports.default = _default;