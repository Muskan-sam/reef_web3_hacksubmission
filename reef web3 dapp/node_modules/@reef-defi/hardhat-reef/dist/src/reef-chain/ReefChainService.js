"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const fs_1 = __importDefault(require("fs"));
const node_fetch_1 = __importDefault(require("node-fetch"));
const os_1 = __importDefault(require("os"));
const REEF_NODE_FOLDER = `${os_1.default.homedir()}/.reef`;
const REEF_NODE_FILE_PATH = `${REEF_NODE_FOLDER}/reef-node-2.1`;
const UNIX_REEF_NODE_RELEASE = "https://github.com/reef-defi/reef-chain/releases/download/testnet-2.1/reef-node";
const KILL_REEF_NODE_COMMAND = "ps -A | grep reef-node | grep -v grep | awk '{print $1}' | xargs kill -9";
class ReefChainService {
    static async createService() {
        await ReefChainService.pullChain();
        return new Promise((resolve, reject) => {
            console.log("Starting Reef-node service!");
            ReefChainService.service = (0, child_process_1.exec)(`${REEF_NODE_FILE_PATH} --dev --tmp`, (err) => {
                if (err) {
                    reject(err.message);
                }
            });
            // TODO timer is set to not show Provider warnings
            // this must be removed in future!
            // timeout constant is also set to some high enough value to ensure chain
            // is up in running when the Provider is called.
            setTimeout(() => resolve(), 3300);
        });
    }
    static async stopService() {
        if (ReefChainService.service) {
            console.log("Stopping Reef-node service!");
            await ReefChainService.killReefProcess();
            ReefChainService.service.kill();
            ReefChainService.service = undefined;
        }
    }
    static async killReefProcess() {
        return new Promise((resolve, reject) => {
            (0, child_process_1.exec)(KILL_REEF_NODE_COMMAND, (err) => {
                err ? reject(err) : resolve();
            });
        });
    }
    // Pull reef chain from reef-chain release
    static async pullChain() {
        if (!fs_1.default.existsSync(REEF_NODE_FOLDER)) {
            fs_1.default.mkdirSync(REEF_NODE_FOLDER);
        }
        if (!fs_1.default.existsSync(REEF_NODE_FILE_PATH)) {
            const buffer = await downloadFile(UNIX_REEF_NODE_RELEASE);
            await saveBufferToFile(buffer, REEF_NODE_FILE_PATH);
            await addPermissions(REEF_NODE_FILE_PATH);
        }
    }
}
exports.default = ReefChainService;
const addPermissions = (filePath) => new Promise((resolve, reject) => {
    (0, child_process_1.exec)(`chmod +x ${filePath}`, (err) => {
        err ? reject(err) : resolve();
    });
});
const downloadFile = async (url) => {
    console.log("Downloading reef-node...");
    return Promise.resolve()
        .then(() => (0, node_fetch_1.default)(url))
        .then((data) => data.buffer());
};
const saveBufferToFile = async (buffer, filePath) => {
    console.log("Saving reef-node...");
    return new Promise((resolve, reject) => {
        fs_1.default.writeFile(filePath, buffer, (err) => {
            err ? reject(err) : resolve();
        });
    });
};
//# sourceMappingURL=ReefChainService.js.map