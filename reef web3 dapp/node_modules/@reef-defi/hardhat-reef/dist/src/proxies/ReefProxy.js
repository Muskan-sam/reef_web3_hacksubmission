"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const api_1 = require("@polkadot/api");
const testingPairs_1 = require("@polkadot/keyring/testingPairs");
const evm_provider_1 = require("@reef-defi/evm-provider");
const axios_1 = __importDefault(require("axios"));
const ethers_1 = require("ethers");
const task_names_1 = require("hardhat/builtin-tasks/task-names");
const solidity_files_cache_1 = require("hardhat/builtin-tasks/utils/solidity-files-cache");
const utils_1 = require("../utils");
class ReefProxy {
    constructor(hre) {
        const config = hre.network.config;
        console.log(`Listening on: ${config.url}`);
        this.hre = hre;
        this.providerUrl = config.url;
        this.seeds = config.seeds ? config.seeds : {};
        this.scanUrl = config.scanUrl;
    }
    async getContractAt(nameOrAbi, address, signer) {
        let artifact;
        if (typeof nameOrAbi === "string") {
            const art = await this.hre.artifacts.readArtifact(nameOrAbi);
            artifact = art.abi;
        }
        else {
            artifact = nameOrAbi;
        }
        return new ethers_1.Contract(address, artifact, signer);
    }
    async getContractFactory(contractName, signer) {
        await this.ensureSetup();
        const wallet = await this.resolveSigner(signer);
        const contract = await this.hre.artifacts.readArtifact(contractName);
        return ethers_1.ContractFactory.fromSolidity(contract).connect(wallet);
    }
    async getSigners() {
        await this.ensureSetup();
        return this.getWallets();
    }
    async getProvider() {
        await this.ensureProvider();
        return ReefProxy.provider;
    }
    async getSigner(address) {
        await this.ensureSetup();
        const wallets = await this.getWallets();
        const addresses = await Promise.all(wallets.map(async (wallet) => wallet.getAddress()));
        const walletIndex = addresses.findIndex((addr) => addr === address);
        (0, utils_1.ensureExpression)(walletIndex !== -1, `Signer with address: ${address} was not found!`);
        return wallets[walletIndex];
    }
    async getSignerByName(name) {
        await this.ensureSetup();
        if (!(name in ReefProxy.wallets)) {
            (0, utils_1.throwError)("Signer does not exist!");
        }
        return ReefProxy.wallets[name];
    }
    async verifyContract(address, name, args, customArgs) {
        if (!this.scanUrl) {
            console.warn("Verification was skipped. Verification URL is missing in config");
            return;
        }
        const sourcePaths = await this.hre.run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_PATHS);
        const sourceNames = await this.hre.run(task_names_1.TASK_COMPILE_SOLIDITY_GET_SOURCE_NAMES, {
            sourcePaths,
        });
        const solidityFilesCachePath = (0, solidity_files_cache_1.getSolidityFilesCachePath)(this.hre.config.paths);
        const solidityFilesCache = await solidity_files_cache_1.SolidityFilesCache.readFromFile(solidityFilesCachePath);
        const dependencyGraph = await this.hre.run(task_names_1.TASK_COMPILE_SOLIDITY_GET_DEPENDENCY_GRAPH, { sourceNames, solidityFilesCache });
        const contractFile = dependencyGraph
            .getResolvedFiles()
            .find((file) => file.content.rawContent.match(new RegExp(`contract ${name}\\s.*`)) ||
            file.content.rawContent.match(new RegExp(`contract ${name}{`)));
        if (!contractFile) {
            throw new Error("Contract was not found and can not be verified!");
        }
        const dependencies = resolveContractDependencies(contractFile, dependencyGraph);
        const source = dependencies.reduce((prev, current) => ({
            ...prev,
            [current.sourceName]: current.content.rawContent,
        }), { [contractFile.sourceName]: contractFile.content.rawContent });
        const compiler = this.hre.config.solidity.compilers[0];
        const foundCompilerVersion = utils_1.availableCompilerVersions.find((version) => version.includes(compiler.version));
        if (!foundCompilerVersion && !customArgs?.compilerVersion) {
            throw new Error("Compiler version was not found");
        }
        const body = {
            name,
            address,
            source: JSON.stringify(source),
            arguments: JSON.stringify(args),
            filename: contractFile.sourceName,
            runs: customArgs?.runs || compiler.settings.optimizer.runs || 200,
            compilerVersion: customArgs?.compilerVersion || foundCompilerVersion,
            target: customArgs?.target || compiler.settings.evmVersion || "london",
            optimization: `${customArgs?.optimization || compiler.settings.optimizer.enabled || false}`,
            license: this.extractLicense(source[contractFile.sourceName]),
        };
        await waitUntilContractExists(this.scanUrl, address);
        await axios_1.default
            .post(`${this.scanUrl}/api/verificator/submit-verification`, body)
            .then((r) => {
            console.log(`Contract ${name} verified!`);
        })
            .catch((err) => {
            console.log(`Contract ${name} was not verified!`);
            console.log(err.message);
        });
    }
    extractLicense(contract, licenseIndicator = "SPDX-License-Identifier") {
        if (!contract.includes(licenseIndicator)) {
            return "";
        }
        return contract
            .split("\n")
            .find((line) => line.includes(licenseIndicator))
            .split(licenseIndicator)[1];
    }
    async getWallets() {
        return Object.entries(ReefProxy.wallets).map(([, value]) => value);
    }
    async resolveSigner(signer) {
        await this.ensureSetup();
        if (signer === undefined) {
            return ReefProxy.wallets.alice;
        }
        if (typeof signer === "string") {
            return this.getSigner(signer);
        }
        return signer;
    }
    async ensureSetup() {
        await this.ensureProvider();
        await this.ensureWallets();
    }
    async ensureProvider() {
        if (!ReefProxy.provider) {
            ReefProxy.provider = new evm_provider_1.Provider({
                provider: new api_1.WsProvider(this.providerUrl),
            });
        }
        await ReefProxy.provider.api.isReady;
    }
    async ensureWallets() {
        const wallets = await this.getWallets();
        if (wallets.length === 0) {
            await this.ensureProvider();
            const testPairs = (0, testingPairs_1.createTestPairs)();
            const signingKeys = new evm_provider_1.TestAccountSigningKey(ReefProxy.provider.api.registry);
            signingKeys.addKeyringPair(Object.values(testPairs));
            const seedPairs = Object.keys(this.seeds).map((key) => ({
                name: key,
                pair: createSeedKeyringPair(this.seeds[key]),
            }));
            signingKeys.addKeyringPair(seedPairs.map(({ pair }) => pair));
            const seedSigners = seedPairs.reduce((acc, { name, pair }) => {
                acc[name] = new evm_provider_1.Signer(ReefProxy.provider, pair.address, signingKeys);
                return acc;
            }, {});
            const testSignersByName = [
                "alice",
                "bob",
                "charlie",
                "dave",
                "eve",
                "ferdie",
            ].reduce((acc, name) => {
                acc[name] = new evm_provider_1.Signer(ReefProxy.provider, testPairs[name].address, signingKeys);
                return acc;
            }, {});
            ReefProxy.wallets = { ...seedSigners, ...testSignersByName };
        }
    }
}
exports.default = ReefProxy;
ReefProxy.wallets = {};
const createSeedKeyringPair = (seed) => {
    const keyring = new api_1.Keyring({ type: "sr25519" });
    return keyring.addFromUri(seed);
};
const resolveContractDependencies = (file, dependencyGraph) => (0, utils_1.compress)(dependencyGraph
    .getDependencies(file)
    .map((innerDep) => [
    innerDep,
    ...resolveContractDependencies(innerDep, dependencyGraph),
]));
const doesContractExist = async (url, address) => axios_1.default
    .get(`${url}/api/contract/${address}`)
    .then((_) => true)
    .catch((_) => false);
// Complete await cicle is in pattern: 1+2+3+...+steps.
// Execution time = steps*(steps+1) / 2 s;
// I.E. Steps = 20; Execution time = 380s
const waitUntilContractExists = async (url, address, steps = 20) => {
    let delayLength = 1000;
    for (let i = 0; i < steps; i++) {
        await (0, utils_1.wait)(delayLength);
        const res = await doesContractExist(url, address);
        if (res) {
            return;
        }
        delayLength += 1000;
    }
    throw new Error("Contract was not detected");
};
//# sourceMappingURL=ReefProxy.js.map