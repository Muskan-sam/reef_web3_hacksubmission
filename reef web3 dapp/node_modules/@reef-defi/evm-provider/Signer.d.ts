import type { BlockTag } from '@ethersproject/abstract-provider';
import { TransactionRequest, TransactionResponse } from '@ethersproject/abstract-provider';
import { Signer as Abstractsigner, TypedDataDomain, TypedDataField, TypedDataSigner } from '@ethersproject/abstract-signer';
import { BigNumber } from '@ethersproject/bignumber';
import { Bytes } from '@ethersproject/bytes';
import { Deferrable } from '@ethersproject/properties';
import { Provider } from './Provider';
import { SigningKey } from './SigningKey';
export declare class Signer extends Abstractsigner implements TypedDataSigner {
    readonly provider: Provider;
    readonly signingKey: SigningKey;
    readonly _substrateAddress: string;
    constructor(provider: Provider, address: string, signingKey: SigningKey);
    connect(provider: Provider): Signer;
    /**
     *
     * @param evmAddress The EVM address to check
     * @returns A promise that resolves to true if the EVM address is claimed
     * or false if the address is not claimed
     */
    isClaimed(evmAddress?: string): Promise<boolean>;
    /**
     * Get the signer's EVM address, and claim an EVM address if it has not claimed one.
     * @returns A promise resolving to the EVM address of the signer's substrate
     * address
     */
    getAddress(): Promise<string>;
    /**
     * Get the signers EVM address if it has claimed one.
     * @returns A promise resolving to the EVM address of the signer's substrate
     * address or an empty string if the EVM address isn't claimed
     */
    queryEvmAddress(): Promise<string>;
    /**
     *
     * @returns The default EVM address generated for the signer's substrate address
     */
    computeDefaultEvmAddress(): string;
    /**
     *
     * @returns The substrate account stored in this Signer
     */
    getSubstrateAddress(): Promise<string>;
    claimEvmAccount(evmAddress: string): Promise<void>;
    /**
     * Claims a default EVM address for this signer's substrate address
     */
    claimDefaultAccount(): Promise<void>;
    getBalance(blockTag?: BlockTag): Promise<BigNumber>;
    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>;
    /**
     *
     * @param transaction
     * @returns A promise that resolves to the transaction's response
     */
    sendTransaction(_transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse>;
    /**
     *
     * @param message The message to sign
     * @returns A promise that resolves to the signed hash of the message
     */
    signMessage(message: Bytes | string): Promise<string>;
    _signMessage(evmAddress: string, message: Bytes | string): Promise<string>;
    _signTypedData(domain: TypedDataDomain, types: Record<string, Array<TypedDataField>>, value: Record<string, any>): Promise<string>;
}
