import { EvmAccountInfo, EvmContractInfo } from '@reef-defi/types/interfaces';
import type { Block, BlockTag, BlockWithTransactions, EventType, FeeData, Filter, Listener, Log, Provider as AbstractProvider, TransactionReceipt, TransactionRequest, TransactionResponse } from '@ethersproject/abstract-provider';
import { Deferrable } from '@ethersproject/properties';
import { BigNumber, BigNumberish } from '@ethersproject/bignumber';
import type { Network } from '@ethersproject/networks';
import Scanner from '@open-web3/scanner';
import { ApiPromise } from '@polkadot/api';
import { ApiOptions } from '@polkadot/api/types';
import { Option } from '@polkadot/types';
import { AbstractDataProvider } from './DataProvider';
export declare class Provider implements AbstractProvider {
    readonly api: ApiPromise;
    readonly resolveApi: Promise<ApiPromise>;
    readonly _isProvider: boolean;
    readonly dataProvider?: AbstractDataProvider;
    readonly scanner: Scanner;
    /**
     *
     * @param _apiOptions
     * @param dataProvider
     */
    constructor(_apiOptions: ApiOptions, dataProvider?: AbstractDataProvider);
    static isProvider(value: any): boolean;
    init(): Promise<void>;
    /**
     * Get the network the provider is connected to.
     * @returns A promise resolving to the name and chain ID of the connected chain.
     */
    getNetwork(): Promise<Network>;
    /**
     * Get the block number of the chain's head.
     * @returns A promise resolving to the block number of the head block.
     */
    getBlockNumber(): Promise<number>;
    getGasPrice(): Promise<BigNumber>;
    getFeeData(): Promise<FeeData>;
    /**
     * Get an account's balance by address or name.
     * @param addressOrName The address or name of the account
     * @param blockTag The block to get the balance of, defaults to the head
     * @returns A promise resolving to the account's balance
     */
    getBalance(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<BigNumber>;
    /**
     * Get the transaction count of an account at a specified block.
     * @param addressOrName The address or name of the account
     * @param blockTag The block to get the transaction count of, defaults to the head block
     * @returns A promise resolving to the account's transaction count
     */
    getTransactionCount(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<number>;
    /**
     * Get the code hash at a given address
     * @param addressOrName The address of the code
     * @param blockTag The block to look up the address, defaults to latest
     * @returns A promise resolving in the code hash
     */
    getCode(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;
    _getBlockTag(blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;
    queryAccountInfo(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<Option<EvmAccountInfo>>;
    queryContractInfo(addressOrName: string | Promise<string>, blockTag?: BlockTag | Promise<BlockTag>): Promise<Option<EvmContractInfo>>;
    /**
     * Get the storage from a block.
     * @param addressOrName The address to retrieve the storage from
     * @param position
     * @param blockTag The block to retrieve the storage from, defaults to head
     * @returns The storage data as a hash
     */
    getStorageAt(addressOrName: string | Promise<string>, position: BigNumberish | Promise<BigNumberish>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;
    /**
     * Unimplemented
     */
    sendTransaction(signedTransaction: string | Promise<string>): Promise<TransactionResponse>;
    /**
     * Submit a transaction to be executed on chain.
     * @param transaction The transaction to call
     * @param blockTag
     * @returns The call result as a hash
     */
    call(transaction: Deferrable<TransactionRequest>, blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;
    /**
     * Estimate gas for a transaction.
     * @param transaction The transaction to estimate the gas of
     * @returns The estimated gas used by this transaction
     */
    estimateGas(transaction: Deferrable<TransactionRequest>): Promise<BigNumber>;
    /**
     * Estimate resources for a transaction.
     * @param transaction The transaction to estimate the resources of
     * @returns The estimated resources used by this transaction
     */
    estimateResources(transaction: Deferrable<TransactionRequest>): Promise<{
        gas: BigNumber;
        storage: BigNumber;
        weightFee: BigNumber;
    }>;
    /**
     * Unimplemented, will always fail.
     */
    getBlock(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<Block>;
    /**
     * Unimplemented, will always fail.
     */
    getBlockWithTransactions(blockHashOrBlockTag: BlockTag | string | Promise<BlockTag | string>): Promise<BlockWithTransactions>;
    /**
     * Unimplemented, will always fail.
     */
    getTransaction(transactionHash: string): Promise<TransactionResponse>;
    getTransactionReceipt(txHash: string): Promise<TransactionReceipt>;
    resolveName(name: string | Promise<string>): Promise<string>;
    lookupAddress(address: string | Promise<string>): Promise<string>;
    /**
     * Unimplemented, will always fail.
     */
    waitForTransaction(transactionHash: string, confirmations?: number, timeout?: number): Promise<TransactionReceipt>;
    /**
     * Get an array of filtered logs from the chain's head.
     * @param filter The filter to apply to the logs
     * @returns A promise that resolves to an array of filtered logs
     */
    getLogs(filter: Filter): Promise<Array<Log>>;
    _fail(operation: string): Promise<any>;
    emit(eventName: EventType, ...args: Array<any>): boolean;
    listenerCount(eventName?: EventType): number;
    listeners(eventName?: EventType): Array<Listener>;
    off(eventName: EventType, listener?: Listener): AbstractProvider;
    on(eventName: EventType, listener: Listener): AbstractProvider;
    once(eventName: EventType, listener: Listener): AbstractProvider;
    removeAllListeners(eventName?: EventType): AbstractProvider;
    addListener(eventName: EventType, listener: Listener): AbstractProvider;
    removeListener(eventName: EventType, listener: Listener): AbstractProvider;
    _resolveTransactionReceipt(transactionHash: string, blockHash: string, from: string): Promise<TransactionReceipt>;
    _resolveBlockHash(blockTag?: BlockTag | Promise<BlockTag>): Promise<string>;
    _resolveBlockNumber(blockTag?: BlockTag | Promise<BlockTag>): Promise<number>;
    _toAddress(addressOrName: string | Promise<string>): Promise<string>;
    _resolveTransaction(tx: Deferrable<TransactionRequest>): Promise<Deferrable<TransactionRequest>>;
    _resolveStorageLimit(tx: Deferrable<TransactionRequest>): Promise<BigNumber>;
}
