"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveAddress = exports.resolveEvmAddress = exports.isSubstrateAddress = exports.dataToString = exports.toBN = exports.handleTxResponse = exports.decodeMessage = exports.createClaimEvmSignature = exports.U64MAX = exports.U32MAX = void 0;
/* eslint-disable prefer-promise-reject-errors */
const bignumber_1 = require("@ethersproject/bignumber");
const util_1 = require("@polkadot/util");
const bn_js_1 = __importDefault(require("bn.js"));
const util_crypto_1 = require("@polkadot/util-crypto");
const strings_1 = require("@ethersproject/strings");
exports.U32MAX = bignumber_1.BigNumber.from('0xffffffff');
exports.U64MAX = bignumber_1.BigNumber.from('0xffffffffffffffff');
function createClaimEvmSignature(substrateAddress) {
    const publicKeySubstrate = (0, util_crypto_1.decodeAddress)(substrateAddress);
    let message = 'reef evm:' + Buffer.from(publicKeySubstrate).toString('hex');
    if (typeof message === 'string') {
        message = (0, strings_1.toUtf8Bytes)(message);
    }
    return message;
}
exports.createClaimEvmSignature = createClaimEvmSignature;
// eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
function decodeMessage(reason, code) {
    const reasonString = JSON.stringify(reason).toLowerCase();
    let codeString = `0x${code.substr(138)}`.replace(/0+$/, '');
    // If the codeString is an odd number of characters, add a trailing 0
    if (codeString.length % 2 === 1) {
        codeString += '0';
    }
    return `${reasonString} ${(0, util_1.hexToString)(codeString)}`;
}
exports.decodeMessage = decodeMessage;
function handleTxResponse(result, api) {
    return new Promise((resolve, reject) => {
        if (result.status.isFinalized || result.status.isInBlock) {
            const createdFailed = result.findRecord('evm', 'CreatedFailed');
            const executedFailed = result.findRecord('evm', 'ExecutedFailed');
            result.events
                .filter(({ event: { section } }) => section === 'system')
                .forEach((event) => {
                const { event: { data, method } } = event;
                if (method === 'ExtrinsicFailed') {
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    const [dispatchError] = data;
                    let message = dispatchError.type;
                    if (dispatchError.isModule) {
                        try {
                            const mod = dispatchError.asModule;
                            const error = api.registry.findMetaError(new Uint8Array([mod.index.toNumber(), mod.error.toNumber()]));
                            message = `${error.section}.${error.name}`;
                        }
                        catch (error) {
                            // swallow
                        }
                    }
                    reject({ message, result });
                }
                else if (method === 'ExtrinsicSuccess') {
                    const failed = createdFailed || executedFailed;
                    if (failed) {
                        reject({
                            message: decodeMessage(failed.event.data[1].toJSON(), failed.event.data[2].toJSON()),
                            result
                        });
                    }
                    resolve({ result });
                }
            });
        }
        else if (result.isError) {
            reject({ result });
        }
    });
}
exports.handleTxResponse = handleTxResponse;
function toBN(bigNumberis = 0) {
    if ((0, util_1.isU8a)(bigNumberis)) {
        return (0, util_1.u8aToBn)(bigNumberis);
    }
    if ((0, util_1.isHex)(bigNumberis)) {
        return (0, util_1.hexToBn)(bigNumberis);
    }
    if (bignumber_1.BigNumber.isBigNumber(bigNumberis)) {
        const hex = bigNumberis.toHexString();
        if (hex[0] === '-') {
            return new bn_js_1.default('-' + hex.substring(3), 16);
        }
        return new bn_js_1.default(hex.substring(2), 16);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return new bn_js_1.default(bigNumberis);
}
exports.toBN = toBN;
function dataToString(bytes) {
    if ((0, util_1.isBuffer)(bytes)) {
        return (0, util_1.u8aToHex)((0, util_1.bufferToU8a)(bytes));
    }
    if ((0, util_1.isU8a)(bytes)) {
        return (0, util_1.u8aToHex)(bytes);
    }
    if (Array.isArray(bytes)) {
        return (0, util_1.u8aToHex)(Buffer.from(bytes));
    }
    return bytes;
}
exports.dataToString = dataToString;
function isSubstrateAddress(address) {
    if (!address) {
        return false;
    }
    try {
        (0, util_crypto_1.encodeAddress)((0, util_1.isHex)(address) ? (0, util_1.hexToU8a)(address) : (0, util_crypto_1.decodeAddress)(address));
    }
    catch (error) {
        return false;
    }
    return true;
}
exports.isSubstrateAddress = isSubstrateAddress;
// returns evm address
function resolveEvmAddress(provider, addressOrName) {
    return __awaiter(this, void 0, void 0, function* () {
        const resolved = yield addressOrName;
        if (resolved.length === 42) {
            return resolved;
        }
        const result = yield provider.api.query.evmAccounts.evmAddresses(resolved);
        return result.toString();
    });
}
exports.resolveEvmAddress = resolveEvmAddress;
// returns Reef native address
function resolveAddress(provider, addressOrName) {
    return __awaiter(this, void 0, void 0, function* () {
        const resolved = yield addressOrName;
        if (isSubstrateAddress(resolved)) {
            return resolved;
        }
        const result = yield provider.api.query.evmAccounts.accounts(resolved);
        return result.toString();
    });
}
exports.resolveAddress = resolveAddress;
//# sourceMappingURL=utils.js.map